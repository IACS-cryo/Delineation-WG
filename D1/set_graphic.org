
#+PROPERTY: header-args:jupyter-python+ :session IDWG

* Table of contents                               :toc_2:noexport:
- [[#introduction][Introduction]]
- [[#setup][Setup]]
- [[#products][Products]]
  - [[#rgi-70][RGI 7.0]]
  - [[#bedmachine-v5][BedMachine v5]]
  - [[#citterio--ahlstrøm-2013][Citterio & Ahlstrøm 2013]]
  - [[#racmo][RACMO]]
  - [[#mar][MAR]]
- [[#sets][Sets]]
  - [[#not-in][Not in]]
  - [[#union][Union]]

* Introduction

Workbook to create set difference graphic

* Setup

#+BEGIN_SRC bash :exports both :results verbatim
grass -c EPSG:3413 ./G_GL
mkdir -p tmp dat
#+END_SRC

* Products
** RGI 7.0

#+BEGIN_SRC bash :exports both :results verbatim
g.mapset -c RGI
v.import input=${DATADIR}/RGI/7.0/regional_files/RGI2000-v7.0-G/RGI2000-v7.0-G-05_greenland_periphery.shp output=RGI
# v.db.select map=RGI|head -n2
g.region vector=RGI res=100 -pa
v.to.rast input=RGI output=mask use=val val=1
r.mapcalc "m_RGI = if(mask)"
#+END_SRC


** BedMachine v5

#+BEGIN_SRC bash :exports both :results verbatim
g.mapset -c BedMachine
r.in.gdal input="NetCDF:${DATADIR}/Morlighem_2017/BedMachineGreenland-v5.nc:mask" output=mask_0
g.region raster=mask_0 -pa
r.mapcalc "mask = if((mask_0 > 1) & (mask_0 < 4), mask_0, null())"

# find largest clump (main ice)
r.clump input=mask output=clumps --o
main_clump=$(r.stats -c -n clumps sort=desc | head -n1 | cut -d" " -f1)

# set main clump to 1, peripheral is 2, shelves ar 3
r.mapcalc "mask = if(clumps == ${main_clump}, 1, mask)" --overwrite

r.mapcalc "m_all = if(mask)"
r.mapcalc "m_main = if(mask == 1, 1, null())"
r.mapcalc "m_peripheral = if(mask == 2, 1, null())"
r.mapcalc "m_shelf = if(mask == 3, 1, null())"
#+END_SRC


** Citterio & Ahlstrøm 2013

#+BEGIN_SRC bash :exports both :results verbatim
g.mapset -c citterio_2013

# doesn't import properly to GRASS (does to QGIS)
# v.import input=${DATADIR}/Citterio_2013/PROMICE_250_2019-12-04_EPSG4326/PROMICE_250_2019-12-04.shp output=mask

mkdir tmp
ogr2ogr -s_srs EPSG:3413 -t_srs EPSG:3413 ./tmp/citterio_2013.gpkg ${DATADIR}/Citterio_2013/PROMICE_3413/
v.in.ogr input=./tmp/citterio_2013.gpkg output=mask
g.region vector=mask res=100 -pa

# v.db.select map=mask|head
# GIC is character but should be numbers
v.db.addcolumn map=mask columns="GICn INT"
db.execute sql='UPDATE mask SET GICn = CAST(GIC AS numeric)'

v.to.rast input=mask output=mask use=attr attribute_column=GICn
# v.out.ogr input=mask output=./dat/citterio_2013.gpkg

r.mapcalc "m_all = if(mask)"
r.mapcalc "m_GIC0 = if(mask == 0, 1, null())"
r.mapcalc "m_GIC1 = if(mask == 1, 1, null())"
r.mapcalc "m_GIC2 = if(mask == 2, 1, null())"
#+END_SRC

** RACMO

#+BEGIN_SRC bash :exports both :results verbatim
g.mapset -c RACMO

FILE=${DATADIR}/RACMO/freshwater/Icemask_Topo_Iceclasses_lon_lat_average_1km.nc 
x0=$(ncdump -v x ${FILE} | grep "^ x =" | cut -d" " -f4 | cut -d, -f1)
x1=$(ncdump -v x ${FILE} | tail -n2 | head -n1 | tr ',' '\n' | tail -n1 | cut -d" " -f2)
y0=$(ncdump -v y ${FILE} | grep "^ y =" | cut -d" " -f4 | cut -d, -f1)
y1=$(ncdump -v y ${FILE} | tail -n2 | head -n1 | tr ',' '\n' | tail -n1 | cut -d" " -f2)
g.region w=$x0 e=$x1 s=$y0 n=$y1 res=1000 -p
g.region s=s-500 n=n+500 e=e+500 w=w-500 -p
g.region save=RACMO

r.in.gdal -o input="NetCDF:${FILE}:Promicemask" output=mask
r.region -c map=mask

r.mapcalc "m_all = if(mask >= 1, 1, null())"
r.mapcalc "m_main = if(mask == 3, 1, null())"
r.mapcalc "m_attached = if(mask == 2, 1, null())"
r.mapcalc "m_peripheral = if(mask == 1, 1, null())"
#+END_SRC

** MAR

MAR NetCDF files don't contain projection information that can be used by GRASS. So I find the bottom, top, left, and right edges by...

+ longitude where lat is max,
+ longitude where lat is min
+ latitude where lon is max
+ latitude where lon is min

Then pass those four through ~m.proj~ to get the x,y bounds of the region in GRASS

#+BEGIN_SRC jupyter-python
import numpy as np
import xarray as xr

ds = xr.open_dataset("/home/kdm/data/MAR/3.13-freshwater/MARv3.13-daily-ERA5-2000.nc")

lon = ds['LON'].values.flatten()
lat = ds['LAT'].values.flatten()

lonmax_idx = np.argmax(lon)
lonmin_idx = np.argmin(lon)
latmax_idx = np.argmax(lat)
latmin_idx = np.argmin(lat)

R = lon[lonmax_idx],lat[lonmax_idx]
L = lon[lonmin_idx],lat[lonmin_idx]
T = lon[latmax_idx],lat[latmax_idx]
B = lon[latmin_idx],lat[latmin_idx]

# bounds
print(pd.DataFrame(index=['T','B','L','R'], columns=['lon','lat'], data=np.vstack((T,B,L,R))))
#+END_SRC

#+RESULTS:
:          lon        lat
: T -45.039822  83.948792
: B -30.694536  58.800426
: L -89.264137  81.557274
: R   7.516274  80.071167

#+BEGIN_SRC bash :results verbatim
g.mapset -c MAR

T=-45.039822,83.948792
B=-30.694536,58.800426
L=-89.264137,81.557274
R=7.516274,80.071167

Txy=$(m.proj -i coordinates=$T)
Bxy=$(m.proj -i coordinates=$B)
Lxy=$(m.proj -i coordinates=$L)
Rxy=$(m.proj -i coordinates=$R)
echo $Txy $Bxy $Lxy $Rxy

N=$(echo ${Txy} | cut -d"|" -f2)
S=$(echo ${Bxy} | cut -d"|" -f2)
E=$(echo ${Rxy} | cut -d"|" -f1)
W=$(echo ${Lxy} | cut -d"|" -f1)

g.region e=$E w=$W s=$S n=$N -pl res=1000
g.region w=w-500 e=e+500 n=n+500 s=s-500 res=1000 -p
g.region save=MAR

r.in.gdal -o input=NetCDF:${DATADIR}/MAR/3.13-freshwater/MARv3.13-daily-ERA5-2000.nc:MSK output=mask
r.region -c map=mask

# find largest clump (main ice)
r.mapcalc "MASK = if(mask == 2)"
r.clump input=mask output=clumps --o
main_clump=$(r.stats -c -n clumps sort=desc | head -n1 | cut -d" " -f1)
# set main clump to 1, peripheral is 2
r.mapcalc "mask = if(clumps == ${main_clump}, 1, mask)" --overwrite
r.mask -r

r.mapcalc "m_all = if(mask)"
r.mapcalc "m_main = if(mask == 1, 1, null())"
r.mapcalc "m_peripheral = if(mask == 2, 1, null())"
#+END_SRC


* Sets

** Not in

#+begin_src bash :exports both :results verbatim
g.mapset -c diff
g.region raster=mask@BedMachine res=1000 -pa

rm -f sets_notin.csv

# rasters=$(g.list -m type=raster mapset=* pattern="m_*")
# RGI first
rasters="m_RGI@RGI $(g.list -m type=raster mapset=* pattern="m_*" | tr ' ' '\n' | grep -v RGI)"

for r0 in $rasters; do
  for r1 in $rasters; do
    r.mapcalc --quiet "tmp = if(${r0} & isnull(${r1}), 1, null())" --overwrite
    non_null_cells=$(r.univar --quiet map=tmp nprocs=8 -t|tail -n1|cut -d"|" -f1)
    echo "${r0},${r1},${non_null_cells}" | tee -a sets_notin.csv
  done
done
#+end_src

#+RESULTS:
: m_RGI@RGI,m_RGI@RGI,


#+name: fig:notin
#+begin_src jupyter-python :exports both
import numpy as np
import pandas as pd

sets = pd.read_csv('sets_notin.csv', names=['x','y','area'])

df = pd.DataFrame()
for o in sets['x'].unique():
    for b in sets['y'].unique():
        area = sets[(sets['x'] == o) & (sets['y'] == b)].area.values
        df.loc[o,b] = area[0]

# print(sets)
df = df * 1000 * 1000 * 1E-6 # convert from grid cells (1000 x 1000 m) to km^2
df.columns = [_[2:] for _ in df.columns]
df.index = [_[2:] for _ in df.index]

d10 = np.log10(df.replace(0,1)).replace(0.1,0)

import seaborn as sns
import matplotlib.pyplot as plt
hm = sns.heatmap(d10,
                 mask = df.isnull(),
                 annot=True,
                 cbar_kws={'label': 'X $\\cap$ Y\' [log$_{10}$ km$^2$]'})
hm.xaxis.tick_top()  # Move x-axis labels to top
hm.set_xticklabels(hm.get_xticklabels(), rotation=90, ha='center')
hm.figure.savefig('./set_notin.png', bbox_inches='tight')
#+end_src
#+CAPTION: Summary of different mask products and their respective “relative complement” (X outside Y) between products. Graphic should be interpreted as X outside Y. For example looking at only the top left 2x2 region, “RGI@RGI” has 10^4.9 = ~80,000 km^2 of ice outside of “GIC0@citterio_2013”, and Citterio 2013 GIC0 has 10^6.2 km^2 outside of RGI. Black 0 indicates product X contained entirely inside product Y. Here “all” is the entire mask, “main” is the main ice, “peripheral” is unconnected ice, and other labels (e.g. GICn) are specific to and documented elsewhere per those data products.

#+RESULTS: fig:notin
[[./figs_tmp/c5b8b1905759b72cafc7c4d94e832f025fc75465.png]]



** Union
#+begin_src bash :exports both :results verbatim
g.mapset -c diff
g.region raster=mask@BedMachine res=1000 -pa

rm -f sets_union.csv

# put RGI first
rasters="m_RGI@RGI $(g.list -m type=raster mapset=* pattern="m_*" | tr ' ' '\n' | grep -v RGI)"
for r0 in $rasters; do
  for r1 in $rasters; do
    r.mapcalc --quiet "tmp = if(${r0} & ${r1}, 1, null())" --overwrite
    non_null_cells=$(r.univar --quiet map=tmp nprocs=8 -t|tail -n1|cut -d"|" -f1)
    echo "${r0},${r1},${non_null_cells}" | tee -a sets_union.csv
  done
done
#+end_src

#+NAME: union
#+begin_src jupyter-python :exports both
import numpy as np
import pandas as pd

sets = pd.read_csv('sets_union.csv', names=['x','y','area'])

df = pd.DataFrame()
for o in sets['x'].unique():
    for b in sets['y'].unique():
        area = sets[(sets['x'] == o) & (sets['y'] == b)].area.values
        df.loc[o,b] = area[0]

# print(sets)
df = df * 1000 * 1000 * 1E-6 # convert from grid cells (1000 x 1000 m) to km^2
df.columns = [_[2:] for _ in df.columns]
df.index = [_[2:] for _ in df.index]

for i,c in enumerate(df.columns):
    for j,r in enumerate(df.index):
        if (i > j):
            df.iloc[j,i] = np.nan

d10 = np.log10(df.replace(0,1)).replace(0.1,0)

import seaborn as sns
import matplotlib.pyplot as plt
hm = sns.heatmap(d10,
                 annot=True,
                 mask = df.isnull(),
                 cbar_kws={'label': 'X $\\cap$ Y [log$_{10}$ km$^2$]'})
hm.figure.savefig('./set_union.png', bbox_inches='tight')
#+end_src
#+caption: Summary of different mask products and their respective overlap or set intersection between products. For example looking at only the top of the left-most column, “RGI@RGI” has 10^4.9 = ~8E4 km^2 of ice overlapping itself, and 10^3.5 = ~3E3 km^2 overlapping Citterio 2013 GIC0. Black 0 indicates no overlap. Here “all” is the entire mask, “main” is the main ice, “peripheral” is unconnected ice, and other labels (e.g. GICn) are specific to and documented elsewhere per those data products.

#+RESULTS: union
[[./figs_tmp/8a376511f44abaaf2551af38863f7cd015611fac.png]]
